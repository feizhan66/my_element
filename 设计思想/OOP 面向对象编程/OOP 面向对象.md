# OOP面向对象

> [文本出处](https://baike.baidu.com/item/OOP/1152915?fr=aladdin)

## 概述

面向对象编程（Object Oriented Programming，OOP，面向对象程序设计）是一种计算机编程架构。OOP 的一条基本原则是计算机程序是由单个能够起到子程序作用的单元或对象组合而成。

## 基本介绍

OOP: Object Oriented Programming,面向对象的程序设计。所谓“对象”在显式支持面向对象的语言中，一般是指类在内存中装载的实例，具有相关的成员变量和成员函数（也称为：方法）。面向对象的程序设计完全不同于传统的面向过程程序设计，它大大地降低了软件开发的难度，使编程就像搭积木一样简单，是当今电脑编程的一股势不可挡的潮流。

OOP 达到了软件工程的三个主要目标：重用性、灵活性和扩展性。为了实现整体运算，每个对象都能够接收信息、处理数据和向其它对象发送信息。OOP 主要有以下的概念和组件：

组件 － 数据和功能一起在运行着的计算机程序中形成的单元，组件在 OOP 计算机程序中是模块和结构化的基础。

抽象性 － 程序有能力忽略正在处理中信息的某些方面，即对信息主要方面关注的能力。

封装 － 也叫做信息封装：确保组件不会以不可预期的方式改变其它组件的内部状态；只有在那些提供了内部状态改变方法的组件中，才可以访问其内部状态。每类组件都提供了一个与其它组件联系的接口，并规定了其它组件进行调用的方法。

多态性 － 组件的引用和类集会涉及到其它许多不同类型的组件，而且引用组件所产生的结果依据实际调用的类型。

继承性 － 允许在现存的组件基础上创建子类组件，这统一并增强了多态性和封装性。典型地来说就是用类来对组件进行分组，而且还可以定义新类为现存的类的扩展，这样就可以将类组织成树形或网状结构，这体现了动作的通用性。

由于抽象性、封装性、重用性以及便于使用等方面的原因，以组件为基础的编程在脚本语言中已经变得特别流行。Python 和 Ruby 是最近才出现的语言，在开发时完全采用了 OOP 的思想，而流行的 Perl 脚本语言从版本5开始也慢慢地加入了新的面向对象的功能组件。用组件代替“现实”上的实体成为 JavaScript（ECMAScript） 得以流行的原因，有论证表明对组件进行适当的组合就可以在英特网上代替 HTML 和 XML 的文档对象模型（DOM）。

## OOP思想

面向对象编程技术的关键性观念是它将数据及对数据的操作行为放在一起，作为一个相互依存、不可分割的整体——对象。对于相同类型的对象进行分类、抽象后，得出共同的特征而形成了类。面向对象编程就是定义这些类。类是描述相同类型的对象集合。类定义好之后将作为数据类型用于创建类的对象。程序的执行表现为一组对象之间的交互通信。对象之间通过公共接口进行通信，从而完成系统功能。类中声明的public成员组成了对象的对外公共接口。 [1]  简单来说就是以功能为解决问题的中心。

## 基本思想
OOP的许多原始思想都来之于Simula语言，并在Smalltalk语言的完善和标准化过程中得到更多的扩展和对以前的思想的重新注解。可以说OO思想和OOPL几乎是同步发展相互促进的。与函数式程序设计（functional-programming）和逻辑式程序设计（logic-programming）所代表的接近于机器的实际计算模型所不同的是，OOP几乎没有引入精确的数学描叙，而是倾向于建立一个对象模型，它能够近似的反映应用领域内的实体之间的关系，其本质是更接近于一种人类认知事物所采用的哲学观的计算模型。由此，导致了一个自然的话题，那就是OOP到底是什么？[D&T 1988][B.S 1991] .。在OOP中，对象作为计算主体，拥有自己的名称，状态以及接受外界消息的接口。在对象模型中，产生新对象，旧对象销毁，发送消息，响应消息就构成OOP计算模型的根本。

对象的产生有两种基本方式。一种是以原型（prototype）对象为基础产生新的对象。一种是以类（class）为基础产生新对象。原型的概念已经在认知心理学中被用来解释概念学习的递增特性，原型模型本身就是企图通过提供一个有代表性的对象为基础来产生各种新的对象，并由此继续产生更符合实际应用的对象。而原型-委托也是OOP中的对象抽象，代码共享机制中的一种。一个类提供了一个或者多个对象的通用性描述。从形式化的观点看，类与类型有关，因此一个类相当于是从该类中产生的实例的集合。而这样的观点也会带来一些矛盾，比较典型的就是在继承体系下，子集（子类）对象和父集（父类）对象之间的行为相融性可能很难达到，这也就是OOP中常被引用的---子类型（subtype）不等于子类（subclass）[Budd 2002]。而在一种所有皆对象的世界观背景下，在类模型基础上还诞生出了一种拥有元类（metaclass）的新对象模型。即类本身也是一种其他类的对象。以上三种根本不同的观点各自定义了三种基于类（class-based）,基于原型（prototype-based）和基于元类（metaclass-based）的对象模型。而这三种对象模型也就导致了许多不同的程序设计语言（如果我们暂时把静态与动态的差别放在一边）。是的，我们经常接触的C++,Java都是使用基于类的对象模型，但除此之外还有很多我们所没有接触的OOPL采用了完全不一样的对象模型，他们是在用另外一种观点诠释OOP的内涵。

什么是oop的基本思想呢？把组件的实现和接口分开，并且让组件具有多态性。不过，两者还是有根本的不同。oop强调在程序构造中语言要素的语法。你必须得继承，使用类，使用对象，对象传递消息。不关心你继承或是不继承，它的开端是分析产品的分类，有些什么种类，他们的行为如何。就是说，两件东西相等意味着什么？怎样正确地定义相等操作？不单单是相等操作那么简单，你往深处分析就会发现“相等”这个一般观念意味着两个对象部分，或者至少基本部分是相等的，据此我们就可以有一个通用的相等操作。再说对象的种类。假设存在一个顺序序列和一组对于顺序序列的操作。那么这些操作的语义是什么？从复杂度权衡的角度看，我们应该向用户提供什么样的顺序序列？该种序列上存在那些操作？那种排序是我们需要的？只有对这些组件的概念型分类搞清楚了，我们才能提到实现的问题：使用模板、继承还是宏？使用什么语言和技术？gp的基本观点是把抽象的软件组件和它们的行为用标准的分类学分类，出发点就是要建造真实的、高效的和不取决于语言的算法和数据结构。当然最终的载体还是语言，没有语言没法编程。stl使用c++，你也可以用ada来实现，用其他的语言来实现也行，结果会有所不同，但基本的东西是一样的。到处都要用到二分查找和排序，而这就是人们正在做的。对于容器的语义，不同的语言会带来轻微的不同。但是基本的区别很清楚是gp所依存的语义，以及语义分解。例如，我们决定需要一个组件swap，然后指出这个组件在不同的语言中如果工作。显然重点是语义以及语义分类。而oop所强调的（我认为是过分强调的）是清楚的定义类之间的层次关系。oop告诉了你如何建立层次关系，却没有告诉你这些关系的实质。

（这段不太好理解，有一些术语可能要过一段时间才会有合适的中文翻译——译者）

面向对象的编程方法OOP是九十年代才流行的一种软件编程方法。它强调对象的“抽象”、“封装”、“继承”、“多态”。我们讲程序设计是由“数据结构”+“算法”组成的。从宏观的角度讲，OOP下的对象是以编程为中心的，是面向程序的对象。


## 特征

1.1面向对象程序设计的特征：
1） 封装
2） 继承
3） 多态
4）抽象

1.2类与数据封装
1.2.1什么是类？
简单的说，类就是一种用户定义的数据类型，跟结构类似；并且，类具有自己的成员变量和成员函数（方法），通过它们可以对类自身进行操作。如：汽车可以看作是发动机、车轮、座椅等诸如此类的集合。也可以从功能的角度来研究，譬如，能移动，加速，减速，刹车等。
例如：
```
class CMyClass1
{
protected:
CMyClass1();
public:
virtual ~ CMyClass1();
}
```
1.2.2 封装（encapsulation）

定义：指能够把一个实体的信息、功能、响应都装入一个单独的对象中的特性。封装的优点如下：
1) 封装允许类的客户不必关心类的工作机理就可以使用它。就象驾驶员不必了解发动机的工作原理就可以驾驶汽车一样，类的客户在使用一个类时也不必了解它是如何工作的，而只需了解它的功能即可。
2) 所有对数据的访问和操作都必须通过特定的方法，否则便无法使用，从而达到数据隐藏的目的。

1.2.3 对象

对象就是类的实例。类与对象的关系就如类型和变量的关系，所有对类的操作都必须通过对象来实现。当一个类定义了多个对象时，每个对象拥有各自的成员数据。

1.2.4 类的三种成员类型

1) 私有成员(private)：缺省情况下，一个类中的所有成员都是私有的。私有成员只能被类本身的成员函数访问。能够被继承但是被继承的私有成员不能够使用。
2) 公有成员(public)：公有成员可以被类成员函数和外部函数使用。
3) 保护成员(protected)：类的保护成员能被类及其派生类的成员函数和友元函数使用，具有继承性。

1.2.5 构造函数与析构函数

1）构造函数
a. 是特殊的成员函数；在创建对象时首先由系统自动调用。它的作用是为新创建的对象分配空间，或为该对象的成员变量赋值等；
b. 构造函数名必须与其类名称完全相同，并且不允许有返回值。
2）析构函数
a. 析构函数是构造函数的逆操作；
b. 析构函数在类名之前加~来命名，它不允许有返回值，也不允许带参数，并且一个类只能有一个析构函数。
1.3继承
1.3.1 传统程序设计的缺点：
增加功能对程序所作的修改工作量非常大。
1.3.2 继承的优点：
继承的方法允许在不改动原程序的基础上对其进行扩充，这样使得原功能得以保存，而新功能也得以扩展。这有利于减少重复编码，提高软件的开发效率。
1.3.3 基类与派生类
1）一个类可以继承其它类的成员，被继承的类叫基类或父类；继承类叫派生类或子类
2）派生类不但拥有自己的成员变量和成员函数，还拥有父类的成员变量和成员函数。
1.3.4 类的保护成员(protected)
前面介绍了类的私有成员只能被类的成员函数和友员函数使用；类的保护成员能被类及其派生类的成员函数和友员函数使用。也就是说，类的保护成员具有继承性，而类的私有成员不具有继承性。
1.3.5 公用基类和私有基类
1）公用基类中的所有public成员在派生类中仍是public成员，所有protected成员在派生类中仍是protected成员。
2）私有基类中的public成员和protected成员在派生类中均变成private成员。
1.3.6 多重继承
1）多重继承的定义方法
例子：
```
class A
{
…
public:
int i;
void func1();
…
};
```

```
class B
{
…
public:
int i;
void func1();
…
};
```

```
class C: public A,B
{
…
void Show()
…
};
```
缺省情况下基类被定义为 private；因此基类B为私有基类。
2）继承的不确定性
例子:
```
class C:public A,B
{
…
void Show()
{
j = i*i;
func1();
}
…
};
```
由于基类A和B中同时拥有数据成员i和成员函数func1，类C引用基类的成员时，系统无法分辨是调用哪一基类的成员而发生错误；
3）解决多重继承的不确定性：
使用域操作符指明要调用的基类，即可解决不确定性问题。
```
class C:public A,B
{
…
int j;
void Show()
{
j = A::i*B::i;
A::func1();
}
…
};
```
1.3.7 多层继承
定义：所谓多层继承指的是从一个类派生出另一个类，然后以派生类作为基类，派生出另一个类，直到最后生成的派生类满足需要为止（见MSDN中的Hierarchy Chart）。
1.3.8 派生类的构造函数与析构函数
在继承关系下，派生类的构造函数负责调用基类的构造函数来设置基类数据成员值。
例：
```
class base
{//基类
…
public:
int i;
base(int j)
{//构造函数
i = j;
}
…
};
```

```
class derived:public base
{//派生类
…
public:
double f;
derived(int, double);
…
};

```

```
derived::derived(int k, double l):base(k)
{//派生类构造函数
…
f = l;
…
}

```
1.3.9 构造函数的调用顺序
1) 在定义派生类对象时，系统首先调用基类的构造函数，然后调用派生类的构造函数；在上例中，derived类首先调用base类的构造函数，然后调用自身的构造函数。
2) 析构函数的调用顺序与构造函数的调用顺序相反。
1.4重载
1.4.1函数重载
1）如果函数有相同的名称和返回值，而有不同的参数个数或参数类型，则这些函数就是重载函数。
2）派生类继承了基类的某一函数，并且又自定义了一个同名函数，有相同的返回值，不同的参数类型或参数个数。这种情况不属于重载。因为它们属于不同的域。
3）例：

```
class base
{
…
void func(int i)
{
…
}
void func(double f)
{
…
}
void func(double f, long q)
{
…
}
…
};

```
1.4.2 操作符重载
重载操作符的定义：返回值类型 operator op (参数表)；其中，op为重载操作符，它必须是VC++中所定义的运算符。然后像定义函数一样定义重载操作符函数。
例子：
```
class person
{
…
int age;
void operator ++();
…
};
void person::operator++()
{
age++;
}
```
1.5虚拟函数与多态性
多态性是面向对象程序设计的精髓之所在，也是C++中最难理解和掌握的部分。在C++中，多态性是建立在虚拟函数基础上的，虚拟函数的使用使类的成员函数表现出多态性。
1.5.1虚拟函数
1）函数的定义：在定义类时在其成员函数前加上关键字virtual；
2）如果基类中成员函数定义为虚函数，则派生类中与其定义完全相同的成员函数，编译器自动将其视为虚函数；
3）只有类的成员函数才能定义为虚函数。
4）虚拟成员函数的存取要看首次定义它的类中，该函数是public还是private。
例：
```
class Insect
{
…
virtual bool CanFly();
…
};
bool Insect :: CanFly()
{
return FALSE;
}
class Butterfly:public Insect
{
…
bool CanFly();
…
};
bool Butterfly :: CanFly()
{
return TRUE;
}
```
1.5.2 虚函数的调用
1） 根据对象的不同而去调用不同类的虚拟函数
2） 可以使用基类对象调用派生类对象，即将派生类对象或指针赋值给基类对象或指针。
3） 反方向的赋值（将基类的对象或指针赋给派生类的对象或指针）是危险的。
例：
```
bool rtn;
Insect inc1,*pInc;
Butterfly btfly;
pInc = &inc1; //pInc指针指向Insect对象
rtn = pInc->CanFly(); //返回FALSE
pInc = &btfly; //pInc指针指向Butterfly对象
rtn = pInc->CanFly(); //返回TRUE
```
1.5.3 虚拟函数与重载函数的区别
1）形式上，重载函数要求有相同的返回值类型和函数名，并有不同的参数序列；而虚拟函数要求三者完全相同。
2）重载函数可以是成员函数或非成员函数；而虚拟函数必须是成员函数。
3）调用方法上，重载函数根据所传递的参数序列的差别作为调用的依据；而虚拟函数则根据调用对象的不同而去调用不同类的函数。
4）虚拟函数在运行时表现出多态功能；而重载函数不具有这一功能。
1.5.4纯虚函数
定义：virtual type funcname(parameter)=0;
C++中有时设计基类就是为了被继承，而基类中的虚拟函数不做任何工作，这种情况下可以将基类中的虚拟函数定义为纯虚函数。包含纯虚函数的类叫抽象类。抽象类不能定义对象，但可以定义指向它的指针。






































































